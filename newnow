# -*- coding: utf-8 -*-
"""
EWS_Fetch.py — 一次抓三個來源資料夾 (Radware / FW / WAF) 的 CSV 附件
儲存到 downloads/<Source>/<YYYYMMDD>/ 檔名不變
以 message-id 做去重，避免重複下載
"""

import os, json
from pathlib import Path
from datetime import datetime, timedelta, timezone

from exchangelib import (
    Credentials, Configuration, Account, DELEGATE,
    FileAttachment, Message
)

# ====== 你現有的連線參數（請替換成你原檔案中的值）======
EWS_URL   = "https://webmail.example.com/EWS/Exchange.asmx"
USERNAME  = "DOMAIN\\user"
PASSWORD  = "pass"
EMAIL     = "soc-report@example.com"

# ====== 來源 → 郵件資料夾（路徑從根開始，支援『收件匣/...』或『Inbox/...』）======
SOURCE_FOLDERS = {
    "Radware": "收件匣/Radware",
    "FW":      "收件匣/FW",
    "WAF":     "收件匣/WAF",
    # "ApexOne": "收件匣/ApexOne",  # 之後開
}

# ====== 輸出與狀態 ======
DOWNLOAD_ROOT = Path("downloads")        # 你已建立 downloads/Radware, FW, WAF
STATE_FILE    = Path("state/ews_state.json")

# ====== 其他參數 ======
ONLY_CSV          = True
PAGE_LIMIT        = 200          # 單次最多處理多少封信
LOOKBACK_DAYS     = 2            # 只掃近幾天的信（效能考量）

# ------------------------------------------------------

def ensure_dir(p: Path):
    p.mkdir(parents=True, exist_ok=True)

def load_state():
    if STATE_FILE.exists():
        return json.loads(STATE_FILE.read_text(encoding="utf-8"))
    return {"processed_ids": []}

def save_state(state: dict):
    ensure_dir(STATE_FILE.parent)
    STATE_FILE.write_text(json.dumps(state, ensure_ascii=False, indent=2), encoding="utf-8")

def connect_account() -> Account:
    creds = Credentials(username=USERNAME, password=PASSWORD)
    cfg = Configuration(server=EWS_URL, credentials=creds)
    return Account(primary_smtp_address=EMAIL, config=cfg, autodiscover=False, access_type=DELEGATE)

def resolve_folder_by_path(account: Account, path_str: str):
    """
    支援 '收件匣/子夾' 或 'Inbox/SubFolder'
    """
    node = account.root
    for seg in filter(None, path_str.split("/")):
        node = node / seg
    return node

def fetch_folder(account: Account, source_key: str, folder_path: str, processed_set: set) -> int:
    """
    從指定資料夾抓 CSV 附件，存到 downloads/<source>/<YYYYMMDD>/...
    回傳下載的附件數
    """
    folder = resolve_folder_by_path(account, folder_path)
    since  = datetime.now(timezone.utc) - timedelta(days=LOOKBACK_DAYS)
    qs = folder.filter(datetime_received__gte=since).order_by("-datetime_received")

    saved = 0
    for item in qs.only("message_id", "datetime_received", "subject", "attachments")[:PAGE_LIMIT]:
        if not isinstance(item, Message):
            continue
        mid = item.message_id
        if mid in processed_set:
            continue

        # 下載附件
        got_any = False
        for att in (item.attachments or []):
            if not isinstance(att, FileAttachment):
                continue
            if ONLY_CSV and not (att.name and att.name.lower().endswith(".csv")):
                continue

            out_dir = DOWNLOAD_ROOT / source_key / item.datetime_received.strftime("%Y%m%d")
            ensure_dir(out_dir)
            out_path = out_dir / att.name

            with open(out_path, "wb") as f:
                f.write(att.content)
            print(f"[{source_key}] saved: {out_path}")
            saved += 1
            got_any = True

        # 無論是否有 CSV，這封信標記為已處理，避免下次重複掃
        processed_set.add(mid)

    return saved

def main():
    ensure_dir(DOWNLOAD_ROOT)
    state = load_state()
    processed = set(state.get("processed_ids", []))

    try:
        acct = connect_account()
    except Exception as e:
        print(f"[ERROR] EWS connect failed: {e}")
        return

    total = 0
    for source_key, folder_path in SOURCE_FOLDERS.items():
        try:
            cnt = fetch_folder(acct, source_key, folder_path, processed)
            total += cnt
        except Exception as e:
            print(f"[WARN] fetch failed for {source_key} ({folder_path}): {e}")

    state["processed_ids"] = list(processed)
    save_state(state)
    print(f"[OK] fetched attachments: {total} file(s)")

if __name__ == "__main__":
    main()