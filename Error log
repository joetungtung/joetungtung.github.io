print(f"[DEBUG][sample time] file={path.name}, head={tcol.head(3).tolist()}")





_EPOCH_RE = re.compile(r"^\d{9,}$")  # 9位以上純數字 → 視為 epoch

def _epoch_to_utc_ts(v: float) -> Optional[pd.Timestamp]:
    try:
        v = float(v)
    except Exception:
        return None
    if v > 1e14:        # ns
        secs = v / 1_000_000_000.0
    elif v > 1e11:      # ms
        secs = v / 1_000.0
    else:               # s
        secs = v
    return pd.Timestamp(datetime.fromtimestamp(secs, tz=timezone.utc))

def to_ts(s: pd.Series) -> pd.Series:
    """
    轉成 UTC Timestamp，容錯強。
    1) 純數字 → epoch
    2) 含時區 → 轉 UTC
    3) 無時區 → 視為 Asia/Taipei，再轉 UTC
    """
    if s is None:
        return pd.Series([], dtype="datetime64[ns, UTC]")

    ss = s.astype(str).str.strip()
    out = pd.Series(pd.NaT, index=ss.index, dtype="datetime64[ns, UTC]")

    is_epoch = ss.str.match(_EPOCH_RE)
    if is_epoch.any():
        out.loc[is_epoch] = ss[is_epoch].apply(_epoch_to_utc_ts)

    others_mask = ~is_epoch
    if others_mask.any():
        # 嘗試解析日期字串
        parsed = pd.to_datetime(ss[others_mask], errors="coerce", utc=False)
        # 如果 pandas 回傳的不是 Series（極端錯誤情況）就跳過
        if not isinstance(parsed, pd.Series):
            return out
        # 解析成功再處理
        if parsed.notna().any():
            has_tz_mask = parsed.dt.tz.notna()
            no_tz_mask  = ~has_tz_mask
            if has_tz_mask.any():
                out.loc[parsed.index[has_tz_mask]] = parsed[has_tz_mask].dt.tz_convert("UTC")
            if no_tz_mask.any():
                localized = parsed[no_tz_mask].dt.tz_localize(
                    ZoneInfo("Asia/Taipei"),
                    nonexistent="shift_forward",
                    ambiguous="NaT",
                )
                out.loc[parsed.index[no_tz_mask]] = localized.dt.tz_convert("UTC")
    return out




from(bucket: "SOC")
  |> range(start: -6h)
  |> filter(fn: (r) => r._measurement == "arcsight_event")
  |> sort(columns: ["_time"], desc: true)
  |> limit(n: 5)





latest =
  from(bucket: "SOC")
    |> range(start: -6h)
    |> filter(fn: (r) => r._measurement == "arcsight_event")
    |> sort(columns: ["_time"], desc: true)
    |> limit(n: 1)

latest
  |> map(fn: (r) => ({
        r with delta_sec: int(
          v: (float(v: uint(v: now())) - float(v: uint(v: r._time))) / 1000000000.0
        )
      }))
