import sqlite3
import re, sys, io

import exchangelib.errors
import yaml
from exchangelib import Credentials, Account, Configuration, DELEGATE, NTLM, EWSTimeZone
from datetime import datetime, timedelta
TPE = EWSTimeZone.localzone()
# ---------- config ----------
'''
def _safe(x):
    try:
        return "" if x is  None else str(x)
    except Exception:
        return "<unreadable>"
'''
def _safe_str(x):
    try:
        return "" if x is None else str(x)
    except Exception:
        return "<unreadable>"

def dump_tree_to_file(account, start="ROOT", max_depth=3, out_path="folder_tree.txt"):
    """
    start: 'ROOT' -> ms_foldelr_root; 'INBOX' -> 收件匣
    """
    root = account.msg_folder_root if start.upper()=="ROOT" else account.inbox
    lines =[f"=== Folder Tree (start: {_safe_str(getattr(root, 'name', '<unknown>f'))}, depth={max_depth}) ==="]

    def walk(node, depth):
        indent = "  " * depth
        name = _safe_str(getattr(node, "name", "<unknown>"))
        absolute = _safe_str(getattr(node, "absolute", ""))
        cls = node.__class__.__name__
        lines.append(f"{indent}- {name}     [{cls}]       {absolute}")
        if depth >= max_depth:
            return
        if hasattr(node, "children") and node.children:
            try:
                for ch in node.children.all():
                    if "Folder" in ch.__class__.__name__:
                        walk(ch, depth + 1)
            except Exception as e:
                lines.append(f"{indent}   <children error: {e}>")
    walk(root, 0)

    with io.open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    print(f"[info] 已輸出資料夾樹到 {out_path}")



def  list_root_children(account, out_path="root_children.txt"):
     """列出 msg_folder_root 第一層資料夾名稱與路徑"""
     root = account.msg_folder_root
     rows = ["=== Root children === "]
     if hasattr(root, "children"):
         for ch in root.children.all():
             rows.append(f"- {_safe_str(getattr(ch, 'name', '<unknown>'))}     {_safe_str(getattr(ch, 'absolute', ''))}")
     with open(out_path, "w", encoding="utf-8") as f:
         f.write("\n".join(rows))
     print(f"[info] 已輸出根目錄第一層到 {out_path}")

def search_folder(account, keyword, out_path="folder_search.txt"):
    """全樹搜尋名稱包含keyword的資料夾"""
    kw = keyword.casefold()
    rows = [f"=== Search '{keyword}' ==="]
    for f in account.root.walk():
        nm = _safe_str(getattr(f, "name", ""))
        if kw in nm.casefold():
            rows.append(f"- {nm}   {_safe_str(getattr(f, 'absolute', ''))}")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(rows))
    print(f"[info] 搜尋結果寫入 {out_path}")

def print_tree(account, start="INBOX", max_depth=2):
    """列出資料夾結構(安全輸出中文;只遞迴資料夾"""
    root = account.inbox if (start.upper()=="INBOX" or start==account.inbox.name) else account.msg_folder_root
    print(f"===資料夾樹(起點:{_safe_str(getattr(root, 'name', '<unknown>'))}，深度:{max_depth})===")

    def walk(node, depth):
        indent = "  " * depth
        print(f"{indent}- {_safe_str(getattr(node, 'name', '<unknown>'))}")
        if depth >= max_depth:
            return
        if hasattr(node, "children"):
            try:
                for ch in node.children.all():
                    walk(ch, depth + 1)
            except Exception:
                pass

    walk(root, 0)

def load_cfg(path="config_detect.yaml"):
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

# ---------- helpers ----------
def field(txt):  # safe str
    return (txt or "").strip()

def body_text(item):
    try:
        return (item.text_body or item.body or "").strip()
    except Exception:
        return (item.body or "").strip()

def any_substr(haystack: str, needles):
    if not needles: return False
    h = (haystack or "").lower()
    return any((n or "").lower() in h for n in needles if n)

def any_regex(text: str, patterns):
    if not patterns: return False
    for pat in patterns:
        if not pat: continue
        if re.search(pat, text or "", flags=re.I):
            return True
    return False

def pad(s, n):
    s = str(s)
    return s[: n-1] + "…" if len(s) > n else s.ljust(n)

def match_one(pattern, text):
    m = re.search(pattern, text or "", flags=re.I)
    return m.group(1) if m else ""

# ---------- EWS ----------
def connect_ews(e):
    creds = Credentials(username=e["username"], password=e["password"])
    conf  = Configuration(service_endpoint=e["service_endpoint"], credentials=creds, auth_type=NTLM)

    #先用config指定的email;沒有的話才嘗試從username判斷
    ps = e.get("primary_smtp_address")
    if not ps:
        ps = e["username"] if "@" in e["username"] else None
    if not ps or "@" not in ps:
        raise ValueError("請在config_detect.yaml 的 exchange.primary_smtp_address 填入你的 email，例如 joe.tung@linebank.com.tw")

    return Account(primary_smtp_address=ps, autodiscover=False, config=conf, access_type=DELEGATE)

def get_folder_by_path(account, path_str: str):
    """
    支援'INBOX/Notice/Dynatrace' 或 '收件匣/Notice/Dynatrace'
    逐層比對(不分大小寫、候選)，找不到就列出該層所有子資料夾輸出錯誤
    """
    if not path_str or not str(path_str).strip():
        print("[debug] path_str 空白，預設用 inbox")
        return account.inbox

    parts = [p.strip() for p in str(path_str).split("/") if p.strip()]
    inbox_display = account.inbox.name #如 收件匣
    print(f"[debug] 要解析的路徑: {path_str} -> parts={parts}  (inbox display='{inbox_display}')")

    #起點:INBOX/收件匣 -> 從INBOX開始，否則從 msg_folder_root
    first = parts[0].casefold()
    if first in ("inbox", inbox_display.casefold(), "收件匣"):
        folder = account.inbox
        parts = parts[1:]
        print(f"[debug] 從inbox開始;剩餘 parts={parts}")
    else:
        folder = account.msg_folder_root #比root更接近使用者資料夾
        print(f"[debug] 從 msg_folder_root 開始;parts={parts}")

    #逐步向下群找(不分大小寫)
    for p in parts:
        want = p.casefold()
        children = list(folder.children.all())
        print(f"[debug] 在「{folder.name}」裡找: '{p}'，此層 {len(children)} 個子資料夾")
        #不分大小寫比對
        match = None
        for ch in children:
            if str(ch.name).casefold() == want:
                match = ch
                break
        #若找不到，嘗試寬鬆比對(去空白、全半形忽略)
        if not match:
            norm = lambda s: str(s).casefold().replace(" ","")
            for ch in children:
                if norm(ch.name) == norm(p):
                    match = ch
                    print(f"[debug] 使用寬鬆比對命中: '{ch.name}'")
                    break
        if not match:
            print(f"[錯誤] 在 「{folder.name}」內找不到: {p}。此層候選")
            for ch in children:
                print(" -", ch.name)
            #嘗試全樹搜尋同名資料夾
            print("[debug] 啟動救援搜尋(全樹尋找同名)...")
            for ch in account.root.walk():
                if str(ch.name).casefold() == want:
                    print(f"[debug] 救援找到: {ch.absolute}")
                    match = ch
                    break
            if not match:
                raise RuntimeError(f"找不到子資料夾 '{p}' 於 '{folder.name}' 之下，也無同名資料匣")
        folder = match

    print(f"[debug] 分析完成 -> {folder.absolute} (name={folder.name})")
    return folder


# ---------- decision (no Jira side-effect) ----------
def decide(cfg, subj: str, body: str):
    text = f"{subj}\n{body}"

    # A) 先看看有沒有 Jira Key（最強特徵）
    keys = re.findall(cfg["regex"]["issue_key"], text)
    if keys:
        return {"action":"LINK_BY_KEY", "issue_key":keys[0], "priority":"", "reason":"主旨/內文包含 Jira Key"}

    # B) 基於内容做基本抽取與預測（之後接 Jira 搜尋）
    host = match_one(cfg["regex"]["host"], text)
    metric = match_one(cfg["regex"]["metric"], text)
    sev = match_one(cfg["regex"]["severity"], text).lower()
    pri = cfg["maps"]["severity_to_priority"].get(sev, "")


    return {
        "action":"CREATE_OR_SEARCH",
        "issue_key":"",
        "priority": pri,
        #"reason": f"告警推測 sev={sev or '-'} host={host or '-'} metric={metric or '-'}"
    }

# ---------- main ----------
def main():
    cfg = load_cfg()

    #建立EWS連線
    acct = connect_ews(cfg["exchange"])

    #先輸出樹撞到檔案
    dump_tree_to_file(acct, start="ROOT", max_depth=3, out_path="folder_tree_root.txt")
    list_root_children(acct, out_path="root_children.txt")
    search_folder(acct, "Notice", out_path="search_notice.txt") #找Dynatrace就修改

    #防呆機制
    box = cfg["exchange"].get("mailbox") or "INBOX"
    print(f"[debug] mailbox from config =", repr(box))
    #box = cfg["exchange"].get("mailbox", "INBOX/Notice/Dynatrace")
    folder = get_folder_by_path(acct, box)
    #print(f"[info] Using mailbox: {box} (resolved folder: {folder.name})")
    print(f"[info] Using mailbox: {box} (resolved: {folder.absolute})")

    lookback_hours = int(cfg["dryrun"].get("lookback_hours", 24) or 0)
    if lookback_hours > 0:
        since = datetime.now(TPE) - timedelta(hours=lookback_hours)
        qs = folder.filter(datetime_received__gt=since).order_by("-datetime_received")
    else:
        qs = folder.all().order_by("-datetime_received")

    items = list(qs)[: cfg["exchange"].get("max_emails_per_run", 100)]

    # 表頭
    print(pad("Date(UTC)", 20), pad("From", 28), pad("Subject", 64),
          pad("Action", 16), pad("Key", 12), pad("Priority", 10), "Reason")
    print("-"*160)

    # 表頭
    #print(pad("Date(UTC)", 20), pad("From", 28), pad("Subject", 64),
    #      pad("Action", 16), pad("Key", 12), pad("Priority", 10), "Reason")
    #print("=" * 160)

    sk = cfg.get("skip", {})
    #for it in items[::-1]: # 舊→新
    items = sorted(folder.filter(datetime_received__gte=since),
                   key=lambda x: x.datetime_received,
                   reverse=True)   #True = 新到舊
    for it in items:  # 新→舊
        dt   = it.datetime_received.astimezone(TPE).strftime("%Y-%m-%d %H:%M:%S")
        frm  = field(getattr(it.sender, "email_address", "")) or field(getattr(it.sender, "name", ""))
        subj = field(it.subject)
        body = body_text(it)

        # ---- 略過規則（只要命中其一就跳過）----
        if any_substr(subj, sk.get("subject_contains")) or any_regex(subj, sk.get("subject_regex")) \
           or any_substr(body, sk.get("body_contains")) or any_regex(body, sk.get("body_regex")) \
           or any_substr(frm,  sk.get("from_contains")):
            print(pad(dt,20), pad(frm,28), pad(subj,64), pad("SKIP",16),
                  pad("",12), pad("",10), "命中 skip 規則")
            continue

        # ---- 沒被略過：進入判斷（之後會接 Jira）----
        result = decide(cfg, subj, body)

        print(pad(dt, 20), pad(frm, 28), pad(subj, 64),
              pad(result["action"], 16), pad(result.get("issue_key", ""), 12),
              pad(result.get("priority", ""), 10), "非skip")
        #print(pad(dt,20), pad(frm,28), pad(subj,64),
        #      pad(result["action"],16), pad(result.get("issue_key",""),12),
        #      pad(result.get("priority",""),10), result.get("reason",""))

if __name__ == "__main__":
        try:
            main()
        except KeyboardInterrupt:
            sys.exit(0)
